<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>JAVA로 게임 개발하기 | Junyong's Portfolio Blog</title><meta name=keywords content><meta name=description content="개요.
처음으로 JAVA를 공부하기 시작한 것은 24년 2학기부터였다.
서강대에서 기초 JAVA강의를 수강했는데 이미 C나 파이썬을 어느 정도 다루기 시작한 이후였기 때문에 수업 내용 이해에는 문제가 없었다.
Class를 기본 단위로 한 채, Class 안에 변수와 메소드를 정의하고 Class간 상속이 가능한 JAVA 특유의 방식은 어떤 이유에서인지 내게 굉장히 매력적으로 느껴졌다.
너무나 쉽게 여러 Class들을 패키지로 묶어 사용한다는 게 흥미로웠고, GUI 프로그래밍도 그 수업에서 처음 배웠는데 굉장히 재미있었다.
사실 나는 23년도쯤에 파이썬 pygame 라이브러리를 사용해서 게임을 만들다가 원하는 퀄리티로 개발하는 것에 실패한 적이 한 번 있었는데, JAVA로 다시 시도하면 보다 쉽게 내가 바라는 퀄리티대로 나오겠다는 생각이 들었다. 그래서 그 학기 중간고사 기간 즈음부터 JAVA로 게임을 만들기 시작했다."><meta name=author content="Hyun, Junyong"><link rel=canonical href=https://GreatseaHyun.github.io/posts/java%EB%A1%9C-%EA%B2%8C%EC%9E%84-%EA%B0%9C%EB%B0%9C%ED%95%98%EA%B8%B0/><link crossorigin=anonymous href=/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css integrity="sha256-j+ECM6cGvIfy4Is8+XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as=style><link rel=icon href=https://GreatseaHyun.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://GreatseaHyun.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://GreatseaHyun.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://GreatseaHyun.github.io/apple-touch-icon.png><link rel=mask-icon href=https://GreatseaHyun.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://GreatseaHyun.github.io/posts/java%EB%A1%9C-%EA%B2%8C%EC%9E%84-%EA%B0%9C%EB%B0%9C%ED%95%98%EA%B8%B0/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://GreatseaHyun.github.io/posts/java%EB%A1%9C-%EA%B2%8C%EC%9E%84-%EA%B0%9C%EB%B0%9C%ED%95%98%EA%B8%B0/"><meta property="og:site_name" content="Junyong's Portfolio Blog"><meta property="og:title" content="JAVA로 게임 개발하기"><meta property="og:description" content="개요.
처음으로 JAVA를 공부하기 시작한 것은 24년 2학기부터였다.
서강대에서 기초 JAVA강의를 수강했는데 이미 C나 파이썬을 어느 정도 다루기 시작한 이후였기 때문에 수업 내용 이해에는 문제가 없었다.
Class를 기본 단위로 한 채, Class 안에 변수와 메소드를 정의하고 Class간 상속이 가능한 JAVA 특유의 방식은 어떤 이유에서인지 내게 굉장히 매력적으로 느껴졌다.
너무나 쉽게 여러 Class들을 패키지로 묶어 사용한다는 게 흥미로웠고, GUI 프로그래밍도 그 수업에서 처음 배웠는데 굉장히 재미있었다.
사실 나는 23년도쯤에 파이썬 pygame 라이브러리를 사용해서 게임을 만들다가 원하는 퀄리티로 개발하는 것에 실패한 적이 한 번 있었는데, JAVA로 다시 시도하면 보다 쉽게 내가 바라는 퀄리티대로 나오겠다는 생각이 들었다. 그래서 그 학기 중간고사 기간 즈음부터 JAVA로 게임을 만들기 시작했다."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-07-05T21:34:50+09:00"><meta property="article:modified_time" content="2025-07-05T21:34:50+09:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="JAVA로 게임 개발하기"><meta name=twitter:description content="개요.
처음으로 JAVA를 공부하기 시작한 것은 24년 2학기부터였다.
서강대에서 기초 JAVA강의를 수강했는데 이미 C나 파이썬을 어느 정도 다루기 시작한 이후였기 때문에 수업 내용 이해에는 문제가 없었다.
Class를 기본 단위로 한 채, Class 안에 변수와 메소드를 정의하고 Class간 상속이 가능한 JAVA 특유의 방식은 어떤 이유에서인지 내게 굉장히 매력적으로 느껴졌다.
너무나 쉽게 여러 Class들을 패키지로 묶어 사용한다는 게 흥미로웠고, GUI 프로그래밍도 그 수업에서 처음 배웠는데 굉장히 재미있었다.
사실 나는 23년도쯤에 파이썬 pygame 라이브러리를 사용해서 게임을 만들다가 원하는 퀄리티로 개발하는 것에 실패한 적이 한 번 있었는데, JAVA로 다시 시도하면 보다 쉽게 내가 바라는 퀄리티대로 나오겠다는 생각이 들었다. 그래서 그 학기 중간고사 기간 즈음부터 JAVA로 게임을 만들기 시작했다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://GreatseaHyun.github.io/posts/"},{"@type":"ListItem","position":2,"name":"JAVA로 게임 개발하기","item":"https://GreatseaHyun.github.io/posts/java%EB%A1%9C-%EA%B2%8C%EC%9E%84-%EA%B0%9C%EB%B0%9C%ED%95%98%EA%B8%B0/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"JAVA로 게임 개발하기","name":"JAVA로 게임 개발하기","description":"개요.\n처음으로 JAVA를 공부하기 시작한 것은 24년 2학기부터였다.\n서강대에서 기초 JAVA강의를 수강했는데 이미 C나 파이썬을 어느 정도 다루기 시작한 이후였기 때문에 수업 내용 이해에는 문제가 없었다.\nClass를 기본 단위로 한 채, Class 안에 변수와 메소드를 정의하고 Class간 상속이 가능한 JAVA 특유의 방식은 어떤 이유에서인지 내게 굉장히 매력적으로 느껴졌다.\n너무나 쉽게 여러 Class들을 패키지로 묶어 사용한다는 게 흥미로웠고, GUI 프로그래밍도 그 수업에서 처음 배웠는데 굉장히 재미있었다.\n사실 나는 23년도쯤에 파이썬 pygame 라이브러리를 사용해서 게임을 만들다가 원하는 퀄리티로 개발하는 것에 실패한 적이 한 번 있었는데, JAVA로 다시 시도하면 보다 쉽게 내가 바라는 퀄리티대로 나오겠다는 생각이 들었다. 그래서 그 학기 중간고사 기간 즈음부터 JAVA로 게임을 만들기 시작했다.\n","keywords":[],"articleBody":"개요.\n처음으로 JAVA를 공부하기 시작한 것은 24년 2학기부터였다.\n서강대에서 기초 JAVA강의를 수강했는데 이미 C나 파이썬을 어느 정도 다루기 시작한 이후였기 때문에 수업 내용 이해에는 문제가 없었다.\nClass를 기본 단위로 한 채, Class 안에 변수와 메소드를 정의하고 Class간 상속이 가능한 JAVA 특유의 방식은 어떤 이유에서인지 내게 굉장히 매력적으로 느껴졌다.\n너무나 쉽게 여러 Class들을 패키지로 묶어 사용한다는 게 흥미로웠고, GUI 프로그래밍도 그 수업에서 처음 배웠는데 굉장히 재미있었다.\n사실 나는 23년도쯤에 파이썬 pygame 라이브러리를 사용해서 게임을 만들다가 원하는 퀄리티로 개발하는 것에 실패한 적이 한 번 있었는데, JAVA로 다시 시도하면 보다 쉽게 내가 바라는 퀄리티대로 나오겠다는 생각이 들었다. 그래서 그 학기 중간고사 기간 즈음부터 JAVA로 게임을 만들기 시작했다.\n게임을 이루는 여러 컴포넌트들을 자바의 각 Class에 완성해 놓고 패키지로 묶어서 게임 로직의 핵심을 이루는 Core.java에서 사용했고, GUI도 최대한 자연스럽게 구성하려고 노력했다.\n학기 도중이었기 때문에 겨울방학이 거의 끝나갈 즈음에야 드디어 내가 머릿속으로 상상하던 게임 개발에 성공했다.\n개발 과정에서 항상 생각지도 못했던 문제들과 버그들이 발생했기 때문에 하나하나 해결해 나가는 과정이 짜증나면서도 그것들을 해결할 때마다 쾌감이 느껴졌기 때문에 포기하지 못했던 것 같다.\n다음 목표는 두 가지가 있다.\n첫째는 현재 .jar 형식으로 release한 게임을 android studio로 다시 만들어 모바일에서 플레이할 수 있게 만드는 것이고, 두 번째는 내가 만든 게임을 인공지능 강화학습으로 train시켜 내가 만든 게임을 플레이할 수 있는 인공지능 모델을 저장하는 것이다.\n강화학습은 이미 25년 4월쯤에 시도해 봤는데, 파이썬으로 dqn 알고리즘을 돌려야 하는데 JAVA-Python간 통신 지연 문제로 에피소드가 끝나야 할때 끊기지 않고 학습에도 문제가 생기는 등 예상치 못한 문제가 잔뜩 발생했다. 그래서 파이썬으로 최대한 비슷하게 다시 개발하거나 쉬운 버전을 만든 후 다시 시도해야 할 것 같고, 7월부터 다시 하고 있다.\n목표.\n최종 완성된 게임의 이름은 ‘크레이지 아케이드 볼’ 이다. 최대한 버그 없이, 사람들이 실제로 재미있어 할 게임을 만드는 것이 목표였다.\n개발 과정에서 사용한 기술 스택.\n프로그래밍 언어: JAVA(GUI 및 게임 로직 개발)\n주요 라이브러리:\nGUI 및 게임 로직 Java Swing-GUI 구성 (JFrame, JPanel, Timer, JOptionPane 등) AWT-그래픽 처리, 이벤트 처리 (Graphics, Color, KeyListener, Rectangle 등)\n이미지 처리 ImageIO- (아이템, 배경, 공 이미지 .png 로딩) awt.Image- 이미지 크기 조정 및 랜더링\n입출력 및 리소스 관리 java.io- 텍스트 파일 입출력(기록 저장) , InputStream 기반 리소스 읽기\n자료구조 및 유틸리티 ArrayList, HashMap,\njava.util- List, Map, Random, Timer, Scanner\n기능 구현 요약:\n이미지 Preloading \u0026 Caching: ImageIO + HashMap + getResourceAsStream() 구조로 이미지 렉 제거/최적화\n게임 루프 구성- javax.swing.Timer\n아이템 효과 - 특정 시간 동안 아이템 효과 구현\n기록 저장- 텍스트 저장 + 불러오기 구현\n충돌 판정- sweep volume 사용한 버그 없는 충돌 판정\n전체 요약: ‘크레이지 아케이드 볼’은 Java 표준 라이브러리만으로 구현된 GUI 기반 아케이드 게임으로, javax.swing과 java.awt를 활용한 그래픽 처리, ImageIO 기반 이미지 로딩, Timer 기반의 애니메이션 루프 및 다양한 아이템 효과 시스템을 포함함. 렉 없는 게임 플레이를 위해 이미지 프리로딩 및 캐싱 구조를 직접 설계하였고, 사용자 기록은 java.io를 통해 텍스트 파일로 저장/불러오는 구조로 처리하였음.\n구현 기능/과정. 게임의 핵심은 플레이어가 방향키로 paddle을 상하좌우로 움직여 15초마다 1개씩 추가되고 속도가 빨라지는 공들을 쳐서 화면 하단의 dangerZone에 공이 닿지 않게 버티는 것이다. 기록 게임이고, dangerZone에 닿으면 생명이 1씩 감소하는데 초기 생명은 난이도 설정에 따라 달라진다. 15초가 지나면 랜덤한 위치에 특수 효과가 있는 아이템들이 나타나고, 플레이어는 paddle로 공을 쳐서 아이템을 맞춤으로서 이로운 효과를 얻을 수 있다. 물론 해로운 아이템도 있다. 생명이 0이 되면 생존 시간이 기록에 저장된다. 그리고 paddle을 움직이면서 공을 때리면 공 속도가 그만큼 빨라지는 로직을 구현했다. 결론적으로 플레이어는 점점 빨라지는 공에 대응해 긍정적 효과를 주는 아이템을 맞추려고 노력해야 오래 버틸 수 있다.\n단순하다고 생각한 규칙이지만 버그를 없애기 위해 굉장히 많은 노력이 필요했다. 당장 생각나는 것들은:\n공이 속도가 빨라지면 paddle을 그대로 통과하는 버그 공이 paddle과 dangerZone 사이에 끼면 곧바로 생명이 0이 되는 버그 아이템 효과가 끝나기 전에 곧바로 재시작을 누르면 다음 시도에서 이상한 효과가 적용되는 버그 아이템이 생성될 때 렉이 걸리는 버그 정도가 있고 사실 더 있었는데 오래되어서 기억이 잘 안 난다. 1번 버그는 공의 속도가 빨라져서 공이 한 프레임 동안 너무 많이 이동할 때 이전 프레임의 위치와 다음 프레임의 위치 사이에 있는 paddle을 통과하게 되는 터널링 현상이었다. 단순히 Rectangle.intersects()를 사용하면 터널링이 발생할 확률이 높고, 그러므로 공의 이동 경로 전체를 고려해서 충돌을 검사하는 로직이 필요했다. 한 프레임에서 공이 (x₁, y₁)에서 (x₂, y₂)로 이동했다고 치면, 그 이동 경로 전체를 포함하는 사각형 영역을 만들고, 그 영역이 paddle과 겹치는지 (intersects())로 판단하면, 중간 경로에서의 충돌도 탐지할 수 있게 된다. 이동 경로 전체를 포함하는 사각형 영역을 sweep volume이라 하고, 수학적으로 표현하면 다음과 같다: 공이 반지름 r을 갖고 현재 위치 P₁ = (x₁, y₁)에서 다음 위치 P₂ = (x₂, y₂)로 이동할 때, 스윕 볼륨(Sweep Volume)은 다음을 포함하는 사각형으로 근사할 수 있다. x_min = min(x₁, x₂) - r\nx_max = max(x₁, x₂) + r\ny_min = min(y₁, y₂) - r\ny_max = max(y₁, y₂) + r\n이를 코드로 표현해보면 Rectangle paddleBounds = p.getBounds(); Rectangle ballBounds = getBounds(); int rInt=(int)radius; // 스윕 볼륨 정의 double nextX = x + spx; double nextY = y + spy; Rectangle sweepVolume = new Rectangle((int) Math.min(x - rInt, nextX - radius), (int) Math.min(y - rInt, nextY - radius), (int) Math.abs(spx) + 2 * rInt, (int)spy + 2 * rInt ); //스윕 볼륨 2: Paddle 아래쪽 충돌 탐지 Rectangle sweepVolume2 = new Rectangle( paddleBounds.x, paddleBounds.y + paddleBounds.height, // Paddle 의 아래쪽 Y좌표 paddleBounds.width, // Paddle 의 너비 Math.max(2 * rInt, (int) Math.abs(spy)) // 최소 높이와 공 속도를 반영 );\n// 스윕 볼륨 3: Paddle 왼쪽 충돌 감지 Rectangle sweepVolume3 = new Rectangle( paddleBounds.x - (int) Math.max(rInt, Math.abs(spx)), // Paddle 왼쪽 paddleBounds.y, Math.max(2 * rInt, (int) Math.abs(spx)), paddleBounds.height ); // 스윕 볼륨 4: Paddle 오른쪽 충돌 감지 Rectangle sweepVolume4 = new Rectangle( paddleBounds.x + paddleBounds.width, paddleBounds.y, Math.max(2 * rInt, (int) Math.abs(spx)), paddleBounds.height);\nif (sweepVolume.intersects(paddleBounds)) { //여기서 paddleBounds인 이유는 공 예상궤적 때문에 handleCollisionUp(paddleBounds, p); // 충돌 처리 limitSpeed(); } else if (sweepVolume2.intersects(ballBounds)) { //ballBounds handleCollisionDown(paddleBounds, p); limitSpeed(); } else if (sweepVolume3.intersects(ballBounds)) { handleCollisionLeft(paddleBounds, p); limitSpeed(); } else if(sweepVolume4.intersects(ballBounds)) { handleCollisionRight(paddleBounds,p); limitSpeed(); } 가 된다.\n보다시피 sweep volume을 paddle의 4면 전체에 적용하니 버그가 사라졌다.\n2번 버그는 Core.java를 작성할 때 dangerZone에 닿은 채로 오래 있으면 순식간에 생명이 떨어지는 문제로, 코드의 구조를 바꾸니 해결되었다.\n3번 버그는 기존 단일 플래그 사용 시 여러 아이템 효과가 동일한 flag/변수를 공유하고 있었기 때문에 만약 아이템 잔여 효과가 끝나기 전에 다음 턴으로 넘어가면 원래 상태 복구 로직 때문에 paddle이 반토막난다던가 하는 꼬임이 발생하는 거엿다. 그렇기에 각 아이템 효과마다 독립된 Timer 객체를 만들어서 실행 및 종료 시점을 정확하게 제어하고, 그 독립된 Timer는 itemEffectTimers라는 리스트에 저장해 관리하는 방식으로 바꾸자 해결되었다.\n4번 버그는 기존 코드가 file io 방식으로 아이템 생성 시마다 일일히 파일에서 읽어오는 방식으로 되어있었기 때문에 생기는 렉이었다. 그렇기 때문에 게임이 시작하는 순간에 필요한 모든 이미지를 미리 읽어두고 메모리에 로드한 후 메모리에 저장한 이미지를 바로바로 꺼내쓰는 방식으로 전환했다. 일일히 InputStream + ImageIO.read -\u003e static hashmap으로 게임 시작할때 1회 저장 후 꺼내서 사용\n성과/배운점. 무턱대고 게임 개발을 시작했을 때가 24년 10월 정도였는데, 그때는 개발 과정이 얼마나 오래 걸릴지 잘 몰랐다. 내가 모르는 것들을 공부하고 게임이 완성되기까지는 생각했던 것보다 훨씬 많은 시간이 필요했다. 그러나 그 과정에서 GUI 프로그래밍 실력이 많이 늘었고, 많은 시간을 사용했지만 결국 성공했기 때문에 많은 성취감을 느낄 수 있었다.\n다만 게임엔진을 사용하면 일일이 날코딩 하는 것보다 비교가 안 되게 빨리 게임을 만들 수 있다는 것은 25년 초가 되어서야 알게 되었다…\n일단 게임이 완성되었다는 것이 성과이고, 그 과정에서 메모리가 어떻게 동작하는지에 대한 이해도 많이 늘었기 때문에 개발을 후회하지는 않는다.\n(다만 망한 생명과학 전공 학점이 슬플 따름…)\n#게임 다운로드:\n실행 파일 (.jar) 실행하려면 Java 17 이상이 설치되어 있어야 합니다.\n설치가 안 되어 있다면 설치 후 실행해주세요. 게임 플레이 후 피드백은 언제든 환영입니다! 이메일 junhsogang@gmail.com\n","wordCount":"1184","inLanguage":"en","datePublished":"2025-07-05T21:34:50+09:00","dateModified":"2025-07-05T21:34:50+09:00","author":{"@type":"Person","name":"Hyun, Junyong"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://GreatseaHyun.github.io/posts/java%EB%A1%9C-%EA%B2%8C%EC%9E%84-%EA%B0%9C%EB%B0%9C%ED%95%98%EA%B8%B0/"},"publisher":{"@type":"Organization","name":"Junyong's Portfolio Blog","logo":{"@type":"ImageObject","url":"https://GreatseaHyun.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://GreatseaHyun.github.io/ accesskey=h title="Junyong's Portfolio Blog (Alt + H)">Junyong's Portfolio Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">JAVA로 게임 개발하기</h1><div class=post-meta><span title='2025-07-05 21:34:50 +0900 KST'>July 5, 2025</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Hyun, Junyong</div></header><div class=post-content><p>개요.</p><p>처음으로 JAVA를 공부하기 시작한 것은 24년 2학기부터였다.</p><p>서강대에서 기초 JAVA강의를 수강했는데 이미 C나 파이썬을 어느 정도 다루기 시작한 이후였기 때문에 수업 내용 이해에는 문제가 없었다.</p><p>Class를 기본 단위로 한 채, Class 안에 변수와 메소드를 정의하고 Class간 상속이 가능한 JAVA 특유의 방식은 어떤 이유에서인지 내게 굉장히 매력적으로 느껴졌다.</p><p>너무나 쉽게 여러 Class들을 패키지로 묶어 사용한다는 게 흥미로웠고, GUI 프로그래밍도 그 수업에서 처음 배웠는데 굉장히 재미있었다.</p><p>사실 나는 23년도쯤에 파이썬 pygame 라이브러리를 사용해서 게임을 만들다가 원하는 퀄리티로 개발하는 것에 실패한 적이 한 번 있었는데, JAVA로 다시 시도하면 보다 쉽게 내가 바라는 퀄리티대로 나오겠다는 생각이 들었다. 그래서 그 학기 중간고사 기간 즈음부터 JAVA로 게임을 만들기 시작했다.</p><p>게임을 이루는 여러 컴포넌트들을 자바의 각 Class에 완성해 놓고 패키지로 묶어서 게임 로직의 핵심을 이루는 Core.java에서 사용했고, GUI도 최대한 자연스럽게 구성하려고 노력했다.</p><p>학기 도중이었기 때문에 겨울방학이 거의 끝나갈 즈음에야 드디어 내가 머릿속으로 상상하던 게임 개발에 성공했다.</p><p>개발 과정에서 항상 생각지도 못했던 문제들과 버그들이 발생했기 때문에 하나하나 해결해 나가는 과정이 짜증나면서도 그것들을 해결할 때마다 쾌감이 느껴졌기 때문에 포기하지 못했던 것 같다.</p><p>다음 목표는 두 가지가 있다.</p><p>첫째는 현재 .jar 형식으로 release한 게임을 android studio로 다시 만들어 모바일에서 플레이할 수 있게 만드는 것이고, 두 번째는 내가 만든 게임을 인공지능 강화학습으로 train시켜 내가 만든 게임을 플레이할 수 있는 인공지능 모델을 저장하는 것이다.</p><p>강화학습은 이미 25년 4월쯤에 시도해 봤는데, 파이썬으로 dqn 알고리즘을 돌려야 하는데 JAVA-Python간 통신 지연 문제로 에피소드가 끝나야 할때 끊기지 않고 학습에도 문제가 생기는 등 예상치 못한 문제가 잔뜩 발생했다. 그래서 파이썬으로 최대한 비슷하게 다시 개발하거나 쉬운 버전을 만든 후 다시 시도해야 할 것 같고, 7월부터 다시 하고 있다.</p><p>목표.</p><p>최종 완성된 게임의 이름은 &lsquo;크레이지 아케이드 볼&rsquo; 이다.
최대한 버그 없이, 사람들이 실제로 재미있어 할 게임을 만드는 것이 목표였다.</p><p><img alt="게임 플레이" loading=lazy src=/images/%EA%B2%8C%EC%9E%84%ED%94%8C%EB%A0%88%EC%9D%B4%ED%99%94%EB%A9%B4.png>
<img alt="아이템 효과" loading=lazy src=/images/%EA%B2%8C%EC%9E%84%ED%94%8C%EB%A0%88%EC%9D%B4%ED%99%94%EB%A9%B42.png></p><p>개발 과정에서 사용한 기술 스택.</p><p>프로그래밍 언어:
JAVA(GUI 및 게임 로직 개발)</p><p>주요 라이브러리:</p><p>GUI 및 게임 로직
Java Swing-GUI 구성 (JFrame, JPanel, Timer, JOptionPane 등)
AWT-그래픽 처리, 이벤트 처리 (Graphics, Color, KeyListener, Rectangle 등)</p><p>이미지 처리
ImageIO- (아이템, 배경, 공 이미지 .png 로딩)
awt.Image- 이미지 크기 조정 및 랜더링</p><p>입출력 및 리소스 관리
java.io- 텍스트 파일 입출력(기록 저장) , InputStream 기반 리소스 읽기</p><p>자료구조 및 유틸리티
ArrayList, HashMap,<br>java.util- List, Map, Random, Timer, Scanner</p><p>기능 구현 요약:</p><p>이미지 Preloading & Caching: ImageIO + HashMap + getResourceAsStream() 구조로 이미지 렉 제거/최적화</p><p>게임 루프 구성- javax.swing.Timer</p><p>아이템 효과 - 특정 시간 동안 아이템 효과 구현</p><p>기록 저장- 텍스트 저장 + 불러오기 구현</p><p>충돌 판정- sweep volume 사용한 버그 없는 충돌 판정</p><p><img alt="이클립스로 완성한 파일들" loading=lazy src=/images/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%EC%86%8C%EC%8A%A4%EC%BD%94%EB%93%9C.png></p><p>전체 요약:
&lsquo;크레이지 아케이드 볼&rsquo;은 Java 표준 라이브러리만으로 구현된 GUI 기반 아케이드 게임으로, javax.swing과 java.awt를 활용한 그래픽 처리, ImageIO 기반 이미지 로딩,
Timer 기반의 애니메이션 루프 및 다양한 아이템 효과 시스템을 포함함.
렉 없는 게임 플레이를 위해 이미지 프리로딩 및 캐싱 구조를 직접 설계하였고, 사용자 기록은 java.io를 통해 텍스트 파일로 저장/불러오는 구조로 처리하였음.</p><p>구현 기능/과정.
게임의 핵심은 플레이어가 방향키로 paddle을 상하좌우로 움직여 15초마다 1개씩 추가되고 속도가 빨라지는 공들을 쳐서 화면 하단의 dangerZone에 공이 닿지 않게 버티는 것이다. 기록 게임이고, dangerZone에 닿으면 생명이 1씩 감소하는데 초기 생명은 난이도 설정에 따라 달라진다. 15초가 지나면 랜덤한 위치에 특수 효과가 있는 아이템들이 나타나고, 플레이어는 paddle로 공을 쳐서 아이템을 맞춤으로서 이로운 효과를 얻을 수 있다. 물론 해로운 아이템도 있다. 생명이 0이 되면 생존 시간이 기록에 저장된다. 그리고 paddle을 움직이면서 공을 때리면 공 속도가 그만큼 빨라지는 로직을 구현했다. 결론적으로 플레이어는 점점 빨라지는 공에 대응해 긍정적 효과를 주는 아이템을 맞추려고 노력해야 오래 버틸 수 있다.</p><p><img alt="게임 시작 화면" loading=lazy src=/images/%EA%B2%8C%EC%9E%84%EC%B4%88%EA%B8%B0%ED%99%94%EB%A9%B4.png>
<img alt="난이도 설정" loading=lazy src=/images/%EA%B2%8C%EC%9E%84%EB%82%9C%EC%9D%B4%EB%8F%84%EC%84%A4%EC%A0%95.png>
<img alt="게임 규칙" loading=lazy src=/images/%EA%B2%8C%EC%9E%84%EA%B7%9C%EC%B9%99.png>
<img alt=기록 loading=lazy src=/images/%EA%B8%B0%EB%A1%9D%EC%A0%80%EC%9E%A5%ED%9B%84%EB%B6%88%EB%9F%AC%EC%98%A4%EA%B8%B0.png></p><p>단순하다고 생각한 규칙이지만 버그를 없애기 위해 굉장히 많은 노력이 필요했다. 당장 생각나는 것들은:</p><ol><li>공이 속도가 빨라지면 paddle을 그대로 통과하는 버그</li><li>공이 paddle과 dangerZone 사이에 끼면 곧바로 생명이 0이 되는 버그</li><li>아이템 효과가 끝나기 전에 곧바로 재시작을 누르면 다음 시도에서 이상한 효과가 적용되는 버그</li><li>아이템이 생성될 때 렉이 걸리는 버그
정도가 있고 사실 더 있었는데 오래되어서 기억이 잘 안 난다.</li></ol><p>1번 버그는 공의 속도가 빨라져서 공이 한 프레임 동안 너무 많이 이동할 때 이전 프레임의 위치와 다음 프레임의 위치 사이에 있는 paddle을 통과하게 되는 터널링 현상이었다. 단순히 Rectangle.intersects()를 사용하면 터널링이 발생할 확률이 높고, 그러므로 공의 이동 경로 전체를 고려해서 충돌을 검사하는 로직이 필요했다. 한 프레임에서 공이 (x₁, y₁)에서 (x₂, y₂)로 이동했다고 치면, 그 이동 경로 전체를 포함하는 사각형 영역을 만들고, 그 영역이 paddle과 겹치는지 (intersects())로 판단하면, 중간 경로에서의 충돌도 탐지할 수 있게 된다. 이동 경로 전체를 포함하는 사각형 영역을 sweep volume이라 하고, 수학적으로 표현하면 다음과 같다:
공이 반지름 r을 갖고 현재 위치 P₁ = (x₁, y₁)에서 다음 위치 P₂ = (x₂, y₂)로 이동할 때,
스윕 볼륨(Sweep Volume)은 다음을 포함하는 사각형으로 근사할 수 있다.
x_min = min(x₁, x₂) - r<br>x_max = max(x₁, x₂) + r<br>y_min = min(y₁, y₂) - r<br>y_max = max(y₁, y₂) + r</p><p>이를 코드로 표현해보면
Rectangle paddleBounds = p.getBounds();
Rectangle ballBounds = getBounds();
int rInt=(int)radius;
// 스윕 볼륨 정의
double nextX = x + spx;
double nextY = y + spy;
Rectangle sweepVolume = new Rectangle((int) Math.min(x - rInt, nextX - radius),
(int) Math.min(y - rInt, nextY - radius),
(int) Math.abs(spx) + 2 * rInt,
(int)spy + 2 * rInt
);
//스윕 볼륨 2: Paddle 아래쪽 충돌 탐지
Rectangle sweepVolume2 = new Rectangle(
paddleBounds.x,
paddleBounds.y + paddleBounds.height, // Paddle 의 아래쪽 Y좌표
paddleBounds.width, // Paddle 의 너비
Math.max(2 * rInt, (int) Math.abs(spy)) // 최소 높이와 공 속도를 반영
);</p><p>// 스윕 볼륨 3: Paddle 왼쪽 충돌 감지
Rectangle sweepVolume3 = new Rectangle(
paddleBounds.x - (int) Math.max(rInt, Math.abs(spx)), // Paddle 왼쪽
paddleBounds.y,
Math.max(2 * rInt, (int) Math.abs(spx)),
paddleBounds.height
);
// 스윕 볼륨 4: Paddle 오른쪽 충돌 감지
Rectangle sweepVolume4 = new Rectangle(
paddleBounds.x + paddleBounds.width,
paddleBounds.y,
Math.max(2 * rInt, (int) Math.abs(spx)),
paddleBounds.height);</p><p>if (sweepVolume.intersects(paddleBounds)) { //여기서 paddleBounds인 이유는 공 예상궤적 때문에
handleCollisionUp(paddleBounds, p); // 충돌 처리
limitSpeed();
}
else if (sweepVolume2.intersects(ballBounds)) { //ballBounds
handleCollisionDown(paddleBounds, p);
limitSpeed();
}
else if (sweepVolume3.intersects(ballBounds)) {
handleCollisionLeft(paddleBounds, p);
limitSpeed();
}
else if(sweepVolume4.intersects(ballBounds)) {
handleCollisionRight(paddleBounds,p);
limitSpeed();
}
가 된다.</p><p>보다시피 sweep volume을 paddle의 4면 전체에 적용하니 버그가 사라졌다.</p><p>2번 버그는 Core.java를 작성할 때 dangerZone에 닿은 채로 오래 있으면 순식간에 생명이 떨어지는 문제로, 코드의 구조를 바꾸니 해결되었다.</p><p>3번 버그는 기존 단일 플래그 사용 시 여러 아이템 효과가 동일한 flag/변수를 공유하고 있었기 때문에 만약 아이템 잔여 효과가 끝나기 전에 다음 턴으로 넘어가면 원래 상태 복구 로직 때문에 paddle이 반토막난다던가 하는 꼬임이 발생하는 거엿다.
그렇기에 각 아이템 효과마다 독립된 Timer 객체를 만들어서 실행 및 종료 시점을 정확하게 제어하고, 그 독립된 Timer는 itemEffectTimers라는 리스트에 저장해 관리하는 방식으로 바꾸자 해결되었다.</p><p>4번 버그는 기존 코드가 file io 방식으로 아이템 생성 시마다 일일히 파일에서 읽어오는 방식으로 되어있었기 때문에 생기는 렉이었다. 그렇기 때문에 게임이 시작하는 순간에 필요한 모든 이미지를 미리 읽어두고 메모리에 로드한 후 메모리에 저장한 이미지를 바로바로 꺼내쓰는 방식으로 전환했다.
일일히 InputStream + ImageIO.read -> static hashmap으로 게임 시작할때 1회 저장 후 꺼내서 사용</p><p>성과/배운점.
무턱대고 게임 개발을 시작했을 때가 24년 10월 정도였는데, 그때는 개발 과정이 얼마나 오래 걸릴지 잘 몰랐다. 내가 모르는 것들을 공부하고 게임이 완성되기까지는 생각했던 것보다 훨씬 많은 시간이 필요했다. 그러나 그 과정에서 GUI 프로그래밍 실력이 많이 늘었고, 많은 시간을 사용했지만 결국 성공했기 때문에 많은 성취감을 느낄 수 있었다.<br>다만 게임엔진을 사용하면 일일이 날코딩 하는 것보다 비교가 안 되게 빨리 게임을 만들 수 있다는 것은 25년 초가 되어서야 알게 되었다&mldr;</p><p>일단 게임이 완성되었다는 것이 성과이고, 그 과정에서 메모리가 어떻게 동작하는지에 대한 이해도 많이 늘었기 때문에 개발을 후회하지는 않는다.</p><p>(다만 망한 생명과학 전공 학점이 슬플 따름&mldr;)</p><p>#게임 다운로드:</p><ul><li><a href=/downloads/CrazyArcadeBall.jar>실행 파일 (.jar)</a></li></ul><blockquote><p>실행하려면 Java 17 이상이 설치되어 있어야 합니다.<br>설치가 안 되어 있다면 설치 후 실행해주세요.
게임 플레이 후 피드백은 언제든 환영입니다!
이메일 <a href=mailto:junhsogang@gmail.com>junhsogang@gmail.com</a></p></blockquote></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://GreatseaHyun.github.io/>Junyong's Portfolio Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>